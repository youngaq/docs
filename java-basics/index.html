<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="canonical" href="https://hicaosen.github.io/docs/java-basics/">
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Java基础 - 我的文档</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Java\u57fa\u7840";
    var mkdocs_page_input_path = "java-basics.md";
    var mkdocs_page_url = "/docs/java-basics/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> 我的文档</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">首页</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../todolist/">备忘录</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Java</span></p>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Java基础</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_1">基本数据类型</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_2">引用类型</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_3">数据类型转换</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_4">修饰符</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_5">访问控制和继承</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_6">非访问修饰符</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_7">类的继承</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_8">方法重写</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_9">异常处理</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#javaio">Java的I/O</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#java_1">Java多线程</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_10">线程同步</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#waitnotifynotifyall">wait()、notify()和notifyAll()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_11">注解</a>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../java-reflection/">Java反射</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../StringBuffer-StringBuilder-diff/">StringBuffer和StringBuilder区别</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Git</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../git-basics/">Git基础</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">我的文档</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Java &raquo;</li>
        
      
    
    <li>Java基础</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/hicaosen/docs/edit/master/docs/java-basics.md"> Edit on hicaosen/docs</a>
      
    </li>
  </ul>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <h1 id="java">Java基础</h1>
<h3 id="_1">基本数据类型</h3>
<pre><code>两大数据类型:内置数据类型,引用数据类型
</code></pre>
<p>八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p>
<ol>
<li>
<p><code>byte</code>数据类型是8位、有符号的，以二进制补码表示的整数；最小值是 -128（-2^7）；最大值是 127（2^7-1）；默认值是 0；byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；</p>
</li>
<li>
<p><code>short</code>数据类型是 16 位、有符号的以二进制补码表示的整数,最小值是 -32768（-2^15）；最大值是 32767（2^15 - 1）；Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；默认值是 0；</p>
</li>
<li>
<p><code>int</code>数据类型是32位、有符号的以二进制补码表示的整数；最小值是 -2,147,483,648（-2^31）；最大值是 2,147,483,647（2^31 - 1）；一般地整型变量默认为 int 类型；默认值是 0 ；</p>
</li>
<li>
<p><code>long</code>数据类型是 64 位、有符号的以二进制补码表示的整数；最小值是 -9,223,372,036,854,775,808（-2^63）；最大值是 9,223,372,036,854,775,807（2^63 -1）；这种类型主要使用在需要比较大整数的系统上；默认值是 0L；</p>
</li>
<li>
<p><code>float</code>数据类型是单精度、32位、符合IEEE 754标准的浮点数；float 在储存大型浮点数组的时候可节省内存空间；默认值是 0.0f；浮点数不能用来表示精确的值，如货币；</p>
</li>
<li>
<p><code>double</code>数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；
浮点数的默认类型为 double 类型；
double类型同样不能表示精确的值，如货币；
默认值是 0.0d；</p>
</li>
<li>
<p><code>boolean</code>数据类型表示一位的信息；只有两个取值：true 和 false；这种类型只作为一种标志来记录 true/false 情况；默认值是 false；</p>
</li>
<li>
<p><code>char</code>类型是一个单一的 16 位 Unicode 字符；最小值是 \u0000（十进制等效值为 0）；最大值是 \uffff（即为 65535）；char 数据类型可以储存任何字符；</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
</tr>
<tr>
<td>char</td>
<td>&lsquo;u0000&rsquo;</td>
</tr>
<tr>
<td>String (or any object)</td>
<td>null</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
</tbody>
</table>
<h3 id="_2">引用类型</h3>
<p>引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。对象、数组都是引用数据类型。所有引用类型的默认值都是null。一个引用变量可以用来引用任何与之兼容的类型。</p>
<h3 id="_3">数据类型转换</h3>
<p>数据类型转换必须满足如下规则：</p>
<ol>
<li>
<p>不能对boolean类型进行类型转换。</p>
</li>
<li>
<p>不能把对象类型转换成不相关类的对象。</p>
</li>
<li>
<p>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</p>
</li>
<li>
<p>转换过程中可能导致溢出或损失精度。</p>
</li>
<li>
<p>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入。</p>
</li>
</ol>
<p>强制类型转换：</p>
<ol>
<li>
<p>条件是转换的数据类型必须是兼容的。</p>
</li>
<li>
<p>格式：(type)value type是要强制类型转换后的数据类型。</p>
</li>
</ol>
<p>隐含强制类型转换：</p>
<ol>
<li>
<p>整数的默认类型是 int。</p>
</li>
<li>
<p>小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f。</p>
</li>
</ol>
<h3 id="_4">修饰符</h3>
<p>访问控制符</p>
<p>访问控制符用来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p>
<ol>
<li>
<p><code>default</code> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</p>
</li>
<li>
<p><code>private</code> : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</p>
</li>
<li>
<p><code>public</code> : 对所有类可见。使用对象：类、接口、变量、方法</p>
</li>
<li>
<p><code>protected</code> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>当前类</th>
<th>同一包内</th>
<th>子孙类(同一包)</th>
<th>子孙类(不同包)</th>
<th>其他包</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>protected</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y/N（说明）</td>
<td>N</td>
</tr>
<tr>
<td>default</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>private</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>default修饰符：</p>
<p>使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为 public static final,而接口里的方法默认情况下访问权限为 public。</p>
<p>private修饰符:</p>
<p>private是最严格的访问级别，所以被声明为 private 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 private。声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问。private访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。</p>
<p>public修饰符:</p>
<p>被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。</p>
<p>protected修饰符：</p>
<p>分两种情况，子类与基类在同一包中：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。protected 可以修饰数据成员，构造方法，方法成员，不能修饰类（内部类除外）。并且接口及接口的成员变量和成员方法不能声明为 protected。</p>
<h3 id="_5">访问控制和继承</h3>
<p>在父类中修饰为public的方法子类中也只能是public,在父类中声明为protected的方法在子类中可以是protected或public不能是private，且private方法不可以被继承。</p>
<h3 id="_6">非访问修饰符</h3>
<p><code>static</code>用来修饰类方法和类变量。</p>
<p><code>final</code>用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</p>
<p><code>abstract</code>用来创建抽象类和抽象方法。</p>
<p><code>synchronized 和 volatile</code>主要用于线程的编程。</p>
<p>static 修饰符：</p>
<p>被static修饰的变量称为静态变量，所有当前类的实例共享静态变量，局部变量不能被声明为静态变量。static修饰的方法称为静态方法，静态方法不能使用类的非静态变量。静态方法从参数列表得到数据。</p>
<p>final 修饰符：</p>
<p>final修饰的变量赋值后不能被重新赋值，并且被修饰的实例变量必须显式指定初始值。final修饰符通常和static修饰符一起使用来创建类常量。父类中的 final 方法可以被子类继承，但是不能被子类重写，声明 final 方法的主要目的是防止该方法被重写。并且final 修饰的类不能被继承，没有类能够继承 final 类的任何特性。</p>
<p>abstract 修饰符：</p>
<ul>
<li>
<p>被abstract修饰的类称为抽象类，抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误，抽象类可以包含抽象方法和非抽象方法。抽象类可以不包含抽象方法。抽象方法的声明以分号结尾。一个类包含抽象方法的类必须声明为抽象类。</p>
</li>
<li>
<p>被abstract修饰的方法称为抽象方法，抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。抽象方法不能被声明成 final 和 static。任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</p>
</li>
</ul>
<p>synchronized 修饰符：</p>
<p>synchronized修饰的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。</p>
<p>transient 修饰符：</p>
<p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</p>
<p>volatile 修饰符：</p>
<p>volatile 修饰的成员变量在被线程访问时强制从共享内存中读取该成员变量的值。当成员变量发生变化时会强制线程将变化值回写到共享内存。在任何时刻两个不同的线程总是看到最新的成员变量值。一个 volatile 对象引用可能是 null。</p>
<h3 id="_7">类的继承</h3>
<p>继承是面向对象程序设计的三个基本原则之一，体现了类与类之间的“is-a”关系。在Java语言中，被继承的类被称为超类，继承类被称为子类。子类继承了超类定义的所有变量和方法，并且子类可以有自己的方法和变量。Java不支持一个子类继承多个超类，然而可以创建类的继承层次结构，子类可以成为另一个子类的超类。类不能是自己的超类。</p>
<p>类的实例变量经常被声明为private，尽管子类拥有其超类的所有成员，但是它依然不能访问被声明为private的超类的成员。</p>
<p>子类可以使用super来调用一个由其超类定义的构造函数：</p>
<p><code>super(parameter-list)</code></p>
<p>parameter-list指定了超类中构造函数所需的任何形参。super()必须是在子类构造函数中执行的第一条语句。</p>
<p>super的第二种形式的用法与this相似，super它引用的是子类的超类。</p>
<p><code>super.member</code></p>
<p>member是超类的方法或实例变量，多用于子类的成员名隐藏了超类中的同名的变量或方法。</p>
<p>在类的层次结构中，构造函数的调用是按照继承的顺序，从超类到子类来进行的。不仅如此，因为super()必须是子类构造函数中执行的第一条语句，所以无论是否使用super()，构造函数的调用顺序都是相同的。如果没有使用super()，就会执行每个超类的默认（无形参）构造函数。</p>
<p>当一个子类对象的引用被赋给一个超类引用变量时，只有权访问对象的那些超类定义的部分。因为超类不知道子类增加了什么。</p>
<h3 id="_8">方法重写</h3>
<p>方法重写组成了Java最为强大的概念之一：动态方法分配（dynamic method dispatch）。动态方法分配是一种机制，通过该机制对一个被重写方法的调用会在运行时解析，而不是在编译时解析。动态方法分配是十分重要的，因为它是Java实现运行时多态性的机制。</p>
<p>当子类中的方法与其超类中的方法具有相同的返回类型和签名时，就称子类中的方法重写（override）了超类中的方法。当在子类中调用被重写的方法时，总是引用子类中定义的方法，而超类中定义的方法将被隐藏。要访问超类的被重写方法可以使用super。</p>
<p>方法重写只在两个方法的签名一致时才发生，但被声明为final的方法不能被重写。</p>
<p>超类引用调用被重写的方法时，Java会根据在调用发生时引用的对象的类型来判断所要执行的方法。当引用不同类型的对象时，将调用被重写方法的不同版本。是被引用对象的类型决定了所要执行的被重写方法。</p>
<h3 id="_9">异常处理</h3>
<p>异常是在运行时发生的错误。</p>
<p>通过程序定义在错误发生时自动执行的代码块来简化错误处理，这个代码块被称为异常处理程序。编写异常处理程序的目的就是消除由异常引起的问题使程序可以继续正常执行。</p>
<p>所有的异常类都是从一个名为Throwable的类派生出来的。Throwable有两个直接子类：Exception和Error。与Error类型异常相关的错误发生在Java虚拟机中，而不是在程序中。
程序活动导致的错误由Exception的子类表示。Exception类有一个重要的子类RuntimeException，用于表示各种常见类型的运行时错误。</p>
<p>Java异常处理是通过5个关键字来管理的，它们是try、catch、throw、throws和finally。它们形成了相互关联的子系统。</p>
<p>如果try代码块中有异常发生就会抛出（throw）该异常。代码可以使用catch捕获并进行处理。系统产生的异常由Java运行时系统自动抛出。如果要手动抛出异常则要使用关键字throw。从一个方法抛出的异常必须用throws语句指定为异常。从try代码块退出时必须被执行的代码都要放在finally代码块中。</p>
<p>异常处理的核心是try和catch。这两个关键字要一起使用，只有try而没有catch，或者只有catch而没有try都不对。</p>
<p>try代码块可以嵌套在另一个try代码块中。由内部try代码块产生的异常如果没有被与该try代码块相关的catch捕获，就会被传送到外部try代码块。</p>
<p>一个try相关的catch语句可以有多个，catch表达式按照在程序中出现的顺序被检查。只执行匹配的语句忽略其他所有的catch代码块。</p>
<p>如果没有抛出异常，那么try代码块就会正常结束，并且会跳过它的所有catch语句，从最后一个catch后面的第一个语句继续执行。因此，只有在有异常被抛出时，才会执行catch语句。</p>
<p>异常的类型必须与catch语句中指定的类型相符，否则异常就不能被捕获。</p>
<p>定义一个退出try/catch代码块时可以执行的代码块。这种方式就是使用finally代码块。无论是出于何种原因，一旦执行流离开try/catch代码块，就会执行finally代码块。即无论try是正常结束，还是由于异常结束，最后都会执行finally定义的代码。如果try代码块中的任何代码或它的任何catch语句从方法返回，也会执行finally代码块。</p>
<p>捕获Java标准异常的附带好处是防止程序异常终止。如果程序不捕获异常那它就要被JVM捕获，程序会终止执行并显示堆栈跟踪和出错消息。</p>
<p>从JDK 7开始增加了3种新的异常功能，第一种新功能支持自动资源管理，当不再需要资源（例如文件）时可以自动释放资源。其基础是一种扩充形式的try，叫做try-with-resources语句。第二种新功能是多重捕获（multi-catch），第三种新功能有时候称为final rethrow或更精确的重新抛出（more precise rethrow）。</p>
<p>创建多重捕获，需要在catch语句中指定异常列表。列表中的每个异常用OR运算符分隔。多重捕获的每个形参隐式地为final不能为其赋新值。</p>
<p><code>catch(final ArithmeticException | ArrayIndexOutOfBoundsException e)</code></p>
<p>所有的Java程序都隐式地引入了java.lang，从RuntimeException派生的多数异常都自动有效，它们不需要被引入到任何方法的throws列表中。在Java语言中编译器不检查方法是否处理或抛出这些异常，所以它们被称为未检查异常（unchecked exception）。如果方法产生异常却无法对其进行处理，就必须在该方法的throws列表中列出。这种异常称为检查异常。</p>
<p>通过使用自定义异常，可以处理与应用程序相关的错误。创建异常很容易，只需定义一个Exception（它是Throwable的子类）的子类即可。Exception类所有的方法继承自Throwable，Throwable定义的方法对于所有的异常，包括你自己创建的异常在内都有效。</p>
<h3 id="javaio">Java的I/O</h3>
<p>Java程序通过流来执行I/O。流是产生或使用信息的抽象。Java I/O系统将流与物理设备相连。</p>
<p>Java定义了两种类型的流：字节流和字符流（Java最初版本只定义了字节流，但很快就添加了字符流）。字节流为处理字节的输入和输出提供了一种便利的方法。字符流是设计用于处理字符输入和输出的。在某些情况下字符流比字节流效率更高。字节流的功能与字符流的功能大部分是并列的，在底层所有I/O都是字节。字符流只是为了更方便处理字符多了一种选择。</p>
<p>字节流的顶端是两个抽象类：InputStream和OutputStream。InputStream定义了字节输入流共有的特点，而OutputStream描述的是字节输出流的行为。</p>
<p>字符流的顶端是两个抽象类：Reader和Writer。Reader用于输入，Writer用于输出。</p>
<p>标准输入、输出流都是字节流。因为预定义流属于没有包含字符流的Java原始规范，所以它们不是字符流而是字节流。</p>
<p>InputStream类和OutputStream类的方法可以根据错误抛出IOException。这两个抽象类定义的方法对于它们的所有子类都是有效的。因此，它们形成了所有字节流的最小I/O功能集。</p>
<h3 id="java_1">Java多线程</h3>
<p>线程是最小的可分派代码单元。
Java的多线程系统建立在Thread类及其对应接口Runnable的基础之上。Thread封装了执行的线程,程序可以扩展Thread或实现Runnable接口。</p>
<p>线程有5种状态：</p>
<ul>
<li>运行状态(running)</li>
<li>就绪状态(ready to run)</li>
<li>等待(wait)</li>
<li>阻塞状态(blocked)</li>
<li>终止(terminated)</li>
</ul>
<p>所有的进程最少有一个被称为主线程的执行线程,Java定义了两种创建可运行对象的方法实现Runnable接口和扩展Thread类。
每个线程都与优先级设置相关。线程的优先级部分决定了相对于其他活动线程，某个线程可以被分配多少CPU时间。总体而言，优先级低的分配的时间少，优先级高的分配的时间多。</p>
<h3 id="_10">线程同步</h3>
<p>有时需要协调两个或多个线程的活动。使线程协调工作的过程称为同步（synchronization）。多个线程操作共享资源的时候就需要同步。</p>
<p>Java中同步的关键是用于控制对象访问的监视器（monitor），每个对象都拥有一个监视器，关键字synchronized和所有对象都具备的几个定义良好的方法都支持同步。当一个对象被一个线程锁住以后其他线程就不能访问该对象，当该线程退出时要为对象解锁。</p>
<p>通过在声明前加上synchronized来创建同步方法</p>
<ul>
<li>对于任何给定对象，一旦同步方法被调用，就会锁住对象，其他线程的执行就不能使用同一对象上的同步方法。</li>
<li>其他线程试图使用正在使用的对象时将进入等待状态，直到对象解锁为止。</li>
<li>当线程离开同步方法时，对象被解锁。</li>
</ul>
<p>除了同步方法之外还可以创建同步块，像下面这样</p>
<pre><code class="language-java">synchronization(obj){
    //TODO 方法内容
}
</code></pre>
<p>一旦进入同步代码块，在退出该块之前，其他线程将不能再调用objref引用的对象的同步方法。</p>
<h3 id="waitnotifynotifyall">wait()、notify()和notifyAll()</h3>
<p>一个同步方法中的名为T的线程正在执行，并且它需要访问一个名为R的资源，但该资源暂时不可用。T应该做什么？如果T进入某种形式的轮询循环来等待R，那么与T相关的对象就不能被其他线程访问。这不是一个最优的解决方案，因为它没有充分利用多线程环境的程序设计优势。更好的解决方案是让T暂时放弃对这些对象的控制，以允许其他线程继续运行。当R可用时，通知T，然后T继续执行。这种方法依赖于某种形式的线程通信，即一个线程可以通知另一个线程它被阻塞，而其他线程也可以通知它继续执行。</p>
<p>wait()、notify()和notifyAll()方法是由Object类实现的。</p>
<p>用法如下：</p>
<p>当一个线程暂时阻塞无法运行时，它调用wait()。这会导致线程睡眠，而对象的监视器会被释放，以允许其他线程使用该对象。当另一个线程进入同一个监视器，调用notify()或notifyAll()时，睡眠线程被唤醒。</p>
<h3 id="_11">注解</h3>
<p>注解类型都自动地扩展了Annotation接口。因此Annotation是所有注解的超接口，它在java.lang.annotation包中声明。
起初，注解仅用来标注声明。这样使用它时，任何类型的声明都可以有一个与之相关联的注解。例如，类、方法、域、形参和enum常量都可以有注解。甚至注解还可以带有注解。在上述所有情况下，注解都位于其余声明部分之前。从JDK 8开始，也可以对类型用法（type use）进行注解，如强制转换类型或方法返回类型。</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../java-reflection/" class="btn btn-neutral float-right" title="Java反射">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../todolist/" class="btn btn-neutral" title="备忘录"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../todolist/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../java-reflection/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
