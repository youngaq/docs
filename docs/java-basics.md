# Java基础

### 基本数据类型

    两大数据类型:内置数据类型,引用数据类型

八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。

1. `byte`数据类型是8位、有符号的，以二进制补码表示的整数；最小值是 -128（-2^7）；最大值是 127（2^7-1）；默认值是 0；byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；

2. `short`数据类型是 16 位、有符号的以二进制补码表示的整数,最小值是 -32768（-2^15）；最大值是 32767（2^15 - 1）；Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；默认值是 0；

3. `int`数据类型是32位、有符号的以二进制补码表示的整数；最小值是 -2,147,483,648（-2^31）；最大值是 2,147,483,647（2^31 - 1）；一般地整型变量默认为 int 类型；默认值是 0 ；

4. `long`数据类型是 64 位、有符号的以二进制补码表示的整数；最小值是 -9,223,372,036,854,775,808（-2^63）；最大值是 9,223,372,036,854,775,807（2^63 -1）；这种类型主要使用在需要比较大整数的系统上；默认值是 0L；

5. `float`数据类型是单精度、32位、符合IEEE 754标准的浮点数；float 在储存大型浮点数组的时候可节省内存空间；默认值是 0.0f；浮点数不能用来表示精确的值，如货币；

6. `double`数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；
浮点数的默认类型为 double 类型；
double类型同样不能表示精确的值，如货币；
默认值是 0.0d；

7. `boolean`数据类型表示一位的信息；只有两个取值：true 和 false；这种类型只作为一种标志来记录 true/false 情况；默认值是 false；

8. `char`类型是一个单一的 16 位 Unicode 字符；最小值是 \u0000（十进制等效值为 0）；最大值是 \uffff（即为 65535）；char 数据类型可以储存任何字符；

| 数据类型 | 默认值 |
|   ----  |----    |
|byte	| 0 |
|short | 0 |
|int | 0 |
|long | 0L |
|float | 0.0f |
|double | 0.0d |
|char | 'u0000' |
|String (or any object)| null |
|boolean | false |

### 引用类型

引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。对象、数组都是引用数据类型。所有引用类型的默认值都是null。一个引用变量可以用来引用任何与之兼容的类型。

### 数据类型转换

数据类型转换必须满足如下规则：

1. 不能对boolean类型进行类型转换。

2. 不能把对象类型转换成不相关类的对象。

3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。

4. 转换过程中可能导致溢出或损失精度。

5. 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入。

强制类型转换：

1. 条件是转换的数据类型必须是兼容的。

2. 格式：(type)value type是要强制类型转换后的数据类型。

隐含强制类型转换：

1. 整数的默认类型是 int。

2. 小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f。

### 修饰符

访问控制符

访问控制符用来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。

1. `default` (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。

2. `private` : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）

3. `public` : 对所有类可见。使用对象：类、接口、变量、方法

4. `protected` : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。

|修饰符| 当前类	|同一包内 |子孙类(同一包) |子孙类(不同包)|其他包|
|----|----|----|----|----|----|
|public|Y|Y|Y|Y|Y|
|protected | Y | Y |Y| Y/N（说明） | N |
|default | Y | Y | Y | N | N |
|private| Y | N | N | | |

default修饰符：

使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为 public static final,而接口里的方法默认情况下访问权限为 public。

private修饰符:

private是最严格的访问级别，所以被声明为 private 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 private。声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问。private访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。

public修饰符:

被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。

protected修饰符：

分两种情况，子类与基类在同一包中：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。protected 可以修饰数据成员，构造方法，方法成员，不能修饰类（内部类除外）。并且接口及接口的成员变量和成员方法不能声明为 protected。

### 访问控制和继承

在父类中修饰为public的方法子类中也只能是public,在父类中声明为protected的方法在子类中可以是protected或public不能是private，且private方法不可以被继承。

### 非访问修饰符

`static`用来修饰类方法和类变量。

`final`用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。

`abstract`用来创建抽象类和抽象方法。

`synchronized 和 volatile`主要用于线程的编程。

static 修饰符：

被static修饰的变量称为静态变量，所有当前类的实例共享静态变量，局部变量不能被声明为静态变量。static修饰的方法称为静态方法，静态方法不能使用类的非静态变量。静态方法从参数列表得到数据。

final 修饰符：

final修饰的变量赋值后不能被重新赋值，并且被修饰的实例变量必须显式指定初始值。final修饰符通常和static修饰符一起使用来创建类常量。父类中的 final 方法可以被子类继承，但是不能被子类重写，声明 final 方法的主要目的是防止该方法被重写。并且final 修饰的类不能被继承，没有类能够继承 final 类的任何特性。

abstract 修饰符：

* 被abstract修饰的类称为抽象类，抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误，抽象类可以包含抽象方法和非抽象方法。抽象类可以不包含抽象方法。抽象方法的声明以分号结尾。一个类包含抽象方法的类必须声明为抽象类。

* 被abstract修饰的方法称为抽象方法，抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。抽象方法不能被声明成 final 和 static。任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。

synchronized 修饰符：

synchronized修饰的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。

transient 修饰符：

序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。

volatile 修饰符：

volatile 修饰的成员变量在被线程访问时强制从共享内存中读取该成员变量的值。当成员变量发生变化时会强制线程将变化值回写到共享内存。在任何时刻两个不同的线程总是看到最新的成员变量值。一个 volatile 对象引用可能是 null。

### 类的继承

继承是面向对象程序设计的三个基本原则之一，体现了类与类之间的“is-a”关系。在Java语言中，被继承的类被称为超类，继承类被称为子类。子类继承了超类定义的所有变量和方法，并且子类可以有自己的方法和变量。Java不支持一个子类继承多个超类，然而可以创建类的继承层次结构，子类可以成为另一个子类的超类。类不能是自己的超类。

类的实例变量经常被声明为private，尽管子类拥有其超类的所有成员，但是它依然不能访问被声明为private的超类的成员。

子类可以使用super来调用一个由其超类定义的构造函数：

`super(parameter-list)`

parameter-list指定了超类中构造函数所需的任何形参。super()必须是在子类构造函数中执行的第一条语句。

super的第二种形式的用法与this相似，super它引用的是子类的超类。

`super.member`

member是超类的方法或实例变量，多用于子类的成员名隐藏了超类中的同名的变量或方法。

在类的层次结构中，构造函数的调用是按照继承的顺序，从超类到子类来进行的。不仅如此，因为super()必须是子类构造函数中执行的第一条语句，所以无论是否使用super()，构造函数的调用顺序都是相同的。如果没有使用super()，就会执行每个超类的默认（无形参）构造函数。

当一个子类对象的引用被赋给一个超类引用变量时，只有权访问对象的那些超类定义的部分。因为超类不知道子类增加了什么。

### 方法重写

方法重写组成了Java最为强大的概念之一：动态方法分配（dynamic method dispatch）。动态方法分配是一种机制，通过该机制对一个被重写方法的调用会在运行时解析，而不是在编译时解析。动态方法分配是十分重要的，因为它是Java实现运行时多态性的机制。

当子类中的方法与其超类中的方法具有相同的返回类型和签名时，就称子类中的方法重写（override）了超类中的方法。当在子类中调用被重写的方法时，总是引用子类中定义的方法，而超类中定义的方法将被隐藏。要访问超类的被重写方法可以使用super。

方法重写只在两个方法的签名一致时才发生，但被声明为final的方法不能被重写。

超类引用调用被重写的方法时，Java会根据在调用发生时引用的对象的类型来判断所要执行的方法。当引用不同类型的对象时，将调用被重写方法的不同版本。是被引用对象的类型决定了所要执行的被重写方法。

### 异常处理

异常是在运行时发生的错误。

通过程序定义在错误发生时自动执行的代码块来简化错误处理，这个代码块被称为异常处理程序。编写异常处理程序的目的就是消除由异常引起的问题使程序可以继续正常执行。

所有的异常类都是从一个名为Throwable的类派生出来的。Throwable有两个直接子类：Exception和Error。与Error类型异常相关的错误发生在Java虚拟机中，而不是在程序中。
程序活动导致的错误由Exception的子类表示。Exception类有一个重要的子类RuntimeException，用于表示各种常见类型的运行时错误。

Java异常处理是通过5个关键字来管理的，它们是try、catch、throw、throws和finally。它们形成了相互关联的子系统。

如果try代码块中有异常发生就会抛出（throw）该异常。代码可以使用catch捕获并进行处理。系统产生的异常由Java运行时系统自动抛出。如果要手动抛出异常则要使用关键字throw。从一个方法抛出的异常必须用throws语句指定为异常。从try代码块退出时必须被执行的代码都要放在finally代码块中。

异常处理的核心是try和catch。这两个关键字要一起使用，只有try而没有catch，或者只有catch而没有try都不对。

try代码块可以嵌套在另一个try代码块中。由内部try代码块产生的异常如果没有被与该try代码块相关的catch捕获，就会被传送到外部try代码块。

一个try相关的catch语句可以有多个，catch表达式按照在程序中出现的顺序被检查。只执行匹配的语句忽略其他所有的catch代码块。

如果没有抛出异常，那么try代码块就会正常结束，并且会跳过它的所有catch语句，从最后一个catch后面的第一个语句继续执行。因此，只有在有异常被抛出时，才会执行catch语句。

异常的类型必须与catch语句中指定的类型相符，否则异常就不能被捕获。

定义一个退出try/catch代码块时可以执行的代码块。这种方式就是使用finally代码块。无论是出于何种原因，一旦执行流离开try/catch代码块，就会执行finally代码块。即无论try是正常结束，还是由于异常结束，最后都会执行finally定义的代码。如果try代码块中的任何代码或它的任何catch语句从方法返回，也会执行finally代码块。

捕获Java标准异常的附带好处是防止程序异常终止。如果程序不捕获异常那它就要被JVM捕获，程序会终止执行并显示堆栈跟踪和出错消息。

从JDK 7开始增加了3种新的异常功能，第一种新功能支持自动资源管理，当不再需要资源（例如文件）时可以自动释放资源。其基础是一种扩充形式的try，叫做try-with-resources语句。第二种新功能是多重捕获（multi-catch），第三种新功能有时候称为final rethrow或更精确的重新抛出（more precise rethrow）。

创建多重捕获，需要在catch语句中指定异常列表。列表中的每个异常用OR运算符分隔。多重捕获的每个形参隐式地为final不能为其赋新值。

`catch(final ArithmeticException | ArrayIndexOutOfBoundsException e) `

所有的Java程序都隐式地引入了java.lang，从RuntimeException派生的多数异常都自动有效，它们不需要被引入到任何方法的throws列表中。在Java语言中编译器不检查方法是否处理或抛出这些异常，所以它们被称为未检查异常（unchecked exception）。如果方法产生异常却无法对其进行处理，就必须在该方法的throws列表中列出。这种异常称为检查异常。

通过使用自定义异常，可以处理与应用程序相关的错误。创建异常很容易，只需定义一个Exception（它是Throwable的子类）的子类即可。Exception类所有的方法继承自Throwable，Throwable定义的方法对于所有的异常，包括你自己创建的异常在内都有效。
